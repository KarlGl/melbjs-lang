/*
  This module accepts the parse tree generated by the parser,
  evaluates each item, and produces the output code to run in js with evaluator.
*/

var expression = require('./modules/expression');
var errors = require('./modules/errors');
var _ = require('../bower_components/lodash/dist/lodash');

exports.run = function(tree) {
    var evalLeaf = function(leaf) {

        if (!leaf.type)
            return leaf;
        if (leaf.type === 'main object') {
            for (var i = 0; i < leaf.body.length - 1; i++) {
              evalLeaf(leaf.body[i]);
            }
            return evalLeaf(leaf.body[leaf.body.length - 1]);
        }
        if (leaf.type === 'expression') {
            // Call the expression as a function. runs evalLeaf.
            return expression.Expression(evalLeaf, leaf).run()
        }
        if (leaf.type === 'hash') {
            var hash = {}
            var modf = function(x, i) {
                return i % 2 === 0
            }
            var keysAndVals = _.select(leaf.body, modf)
            var keys = _.select(keysAndVals, modf)
            var vals = _.select(keysAndVals,
                function(x, i) {
                    return i % 2 === 1
                });

            return "Object({" + _.reduce(_.zip(keys, vals),
                function(ac, pair) {
                    errors.throwIfFalse(pair[0], "No lhs of hash")
                    errors.throwIfFalse(pair[1], "No rhs of hash")
                    return ac.concat(evalLeaf(pair[0]) + ": " + evalLeaf(pair[1]))
                }, []).join(",") + "});"
        }

        // native data types.
        if (leaf.type === 'identifier') {
            // if whitespace, ignore it.
            if (/\s/.test(leaf.value))
                return "";
            return leaf.value.toString();
        }
    }

    return evalLeaf(tree)
}
